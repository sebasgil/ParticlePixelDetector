"""
Reconstruction of paths from events.
"""

import numpy as np
from common import DetectorGeometry, Event #Do we need DetectorGeometry here?


class ReconstructedPath:
    """
    A single reconstructed path through the Detector.
    """
    def __init__(self, event_id, direction, centroid):
        self.event_id = event_id
        self.direction = direction
        self.centroid = centroid


class Reconstructor:
    """
    Reconstructs paths from events.
    """
    def __init__(self, number_of_iterations: int):
        self.number_of_iterations = number_of_iterations

    def reconstruct_from_event(self, event: Event) -> ReconstructedPath:
        """
        Reconstruct a single path from a single event.

        Parameters
        ----------
        # TODO: wording
        event: The event whose original path is to be reconstructed.
        """
        

        reconstructed_path = ReconstructedPath(
            event.get_id(),
            find_direction(
                event.get_activated_pixel_positions(),
                self.number_of_iterations
            ),
            find_centroid(event.get_activated_pixel_positions())
        )

        return reconstructed_path


def find_centroid(pixel_info):
    """
    Finds centroid of the given points
    """
    centroid = np.mean(pixel_info, axis=0)
    return centroid


def find_direction(pixel_info, number_of_iterations):
    """
    Uses the data from an event to find the direction of the line that 
    best fits the activated pixels  
    For more information on how this works please visit https://zalo.github.io/blog/line-fitting/ 
    """

    check_pixel_info(pixel_info)

    centroid = find_centroid(pixel_info)
    direction = np.array([0.0, 0.0, 1.0]) #this is our initial direction
    for _ in range(number_of_iterations):
        next_direction = np.array([0.0, 0.0, 0.0])

        for point in pixel_info:
            point_vec = point - centroid

            dot = np.dot(direction, point_vec)

            next_direction += dot*point_vec

        norm = np.dot(next_direction, next_direction)

        direction = (1/(norm**(0.5)))*next_direction

    return direction


def distance_func(point, point_on_line, dcs_of_line):
    """
    Finds the distance of the "point" from the line passing through 
    "point_on_line" and having the direction cosines "dcs_of_line"
    """
    centroid = point_on_line  # any point on the line
    direction = dcs_of_line  # direction cosines of the line
    vector_to_centroid = centroid - point
    area_of_parallelogram = np.cross(vector_to_centroid, direction)

    distance = (
        np.dot(area_of_parallelogram, area_of_parallelogram)
        / np.dot(direction, direction)
    )

    distance = (abs(distance))**(0.5)

    return distance


def measure_error(set_of_points, pixel_info, number_of_iterations):
    """
    Finds the sum of the squared of the distances at which the 
    "set_of_points" lie from the line generated by 
    find_direction(pixel_info, number_of_iterations)
    In the case where set_of_points = pixel_info this function
    gives us an estimate of how poorly the line generated fits
    the points.
    """
    sum_errors = 0.0
    centroid = find_centroid(pixel_info)
    direction = find_direction(pixel_info, number_of_iterations)
    for point in set_of_points:
        distance = distance_func(
            point,
            centroid,
            direction
        )
        sum_errors += (distance*distance)

    return sum_errors

def inv_confidence(pixel_info): 
    """
    Short for inverse confidence, this fucntion measures the "isotropy"
    of the points around the centroid. If high this means that the 
    points are isotropically distributed around the centroid. 
    """
    centroid = find_centroid(pixel_info)
    sum_of_dot_products = 0.0
    confidence = 0.0
    for point in pixel_info:
        pointing_vector = point - centroid
        sum_of_dot_products += np.dot(pointing_vector,pointing_vector)
    
    average_of_dot_products = (sum_of_dot_products/len(pixel_info))

    for point in pixel_info:
        pointing_vector = point - centroid
        confidence += abs(np.dot(pointing_vector,pointing_vector) - average_of_dot_products)
    
    confidence = (confidence/average_of_dot_products)

    return confidence

def relative_error(pixel_info, number_of_iterations):
    """
    This function measures the variation in the distances at which
    each point lies from the line generated by find_direction(). If high
    this means that the points we are trying to fit a straight line to might
    not actually be points derived from a line.
    """
    centroid = find_centroid(pixel_info)
    direction = find_centroid(pixel_info, number_of_iterations)
    average_error = measure_error(pixel_info, pixel_info, number_of_iterations)/len(pixel_info)
    relative_error = 0.0

    for point in pixel_info:
        distance = distance_func(point, centroid, direction)
        relative_error += ((distance*distance) - average_error)
    
    relative_error = (relative_error/average_error)

    return relative_error

def check_pixel_info(pixel_info):
    """
    Checks for degenerate points in pixel_info
    """ 

    for (idx_1, point_1) in enumerate(pixel_info):
        for (idx_2, point_2) in enumerate(pixel_info):
            if idx_1 == idx_2:
                break
            if (point_1 == point_2).all():
                raise ValueError("There is atleast one repeated point in the points provided.")

